<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>DICOM Upload + Inference</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <!-- <link rel="stylesheet" href="light.css" /> -->

</head>

<body style="font-family: sans-serif">
  <header style="
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 56px;
  padding: 0 20px;
  background-color: #111;
  border-bottom: 1px solid #444;
  color: white;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  box-sizing: border-box;
">
    <!-- ì¢Œì¸¡ -->
    <!-- ê°€ìš´ë° (ë¡œê³  + í…ìŠ¤íŠ¸) -->
    <!-- âœ… ë¡œê³  ì˜ì—­ -->
    <div style="display: flex; align-items: center;">
      <img src="../images/logo.png" alt="Liveraizer Logo" style="
      height: 36px;
      object-fit: contain;
      display: block;
    ">
    </div>

    <!-- ìš°ì¸¡ (ë²„íŠ¼) -->
    <div style="display: flex; align-items: center;">
      <button id="undoBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">â†©ï¸</button>

      <button id="editorBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">âœ‚ï¸</button>

      <button id="drawBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      cursor: pointer;
    ">ğŸ–Œï¸</button>

      <button id="editModeBtn" style="
      padding: 6px 12px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #0066cc;   /* íŒŒë€ìƒ‰ ë°°ê²½ */
      color: white;
      cursor: pointer;
      margin-left: 4px;
    ">ğŸ¯ ë¶€ë¶„</button>


    </div>
    <div style="display: flex; align-items: center; gap: 10px;">
      <input type="file" id="folderInput" webkitdirectory multiple style="
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #666;
      background: #222;
      color: white;
      font-size: 14px;
    " />
      <span id="status" style="font-size: 14px; color: #ccc;">ì§„í–‰ ì¤‘ ì—†ìŒ</span>
    </div>
    <input type="file" id="dicomInput" webkitdirectory multiple />
    <!-- <p id="status">ìƒíƒœ ë©”ì‹œì§€</p> -->
  </header>
  <div id="mainLayout">
    <div id="meshSidebar">
      <div id="meshList"></div>
      <div id="segmentEditControllers">
        <div>Diameter</div>

        <input id="brushSlider" type="range" min="0" max="1" step="0.01"></input>
      </div>
    </div>

    <div id="viewerArea">
      <div id="viewerContentArea" style="flex:1; display:flex; flex-direction:column;">
        <!-- Top Mesh Area-->

        <div class="viewport-top">
          <div id="leftTopContainer">
            <canvas id="leftTop"></canvas>
          </div>

          <div id="bottomHalf" style="position: relative;">
            <div id="labelContainer" style="position:absolute; top:0; left:0; pointer-events:none; z-index:20;"></div>
            <canvas id="threeCanvas"></canvas>
            <canvas id="lassoCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
            <div id="scissorIcon" style="
              position: absolute;
              z-index: 100;
              pointer-events: none;
              display: none;
              font-size: 20px;
            ">âœ‚ï¸</div>
          </div>
        </div>
        <!-- Third 2D Image Area-->
        <div id="topViewer" style="height: 300px;">
          <canvas id="canvasTop" style="width:100%; height:100%;"></canvas>
          <canvas id="canvasMulti" style="width:100%; height:100%"></canvas>
        </div>
      </div>
    </div>

    <div id="volumeTableArea">
      <div id="volumeTableContent"></div>
    </div>
  </div>
  <style>
    .viewport-top {
      height: 50%;
      width: 100%;

      background-color: #fff;

      display: flex;
      flex-direction: row;
    }

    #leftTopContainer {
      width: 50%;
      height: 100%;
    }

    #leftTop {
      width: 100%;
      height: 100%;
      display: block;
      background-color: gray;
      border-color: red;
      border-style: solid;
    }

    #topViewer {
      height: 50%;
    }

    #lassoCanvas {
      width: 100%;
      height: 100%;
      z-index: 10;
    }

    #segmentEditControllers {
      display: flex;
      flex-direction: column;
      color: white;
      display: none;
    }

    #brushSlider {
      width: 100%;
    }
  </style>
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
  }
}
</script>
  <script type="module">
    import JSZip from 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm';

    import * as THREE from "three";
    import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
    import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
    import { NRRDLoader } from 'three/examples/jsm/loaders/NRRDLoader.js';

    import { OBJExporter } from "three/examples/jsm/exporters/OBJExporter.js";

    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls.js';

    import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';

    import { renderNrrdMesh } from './viewer/renderNrrdMesh.js';
    import {
      labelColorMap, labelNameMap,
      applyColorTheme, createNiivueLUT, applyMeshColors
    } from './viewer/colorMaps.js';

    import { marchingCubes } from './utils/marchingCubes.js';
    import { uploadAndInferDicomBundle } from './upload/uploadAndInferDicomBundle.js';

    import * as niivue from '../dist/index.js'; // ë˜ëŠ” CDN ì‚¬ìš©

    import { LassoEditor } from './editor/lassoEditor.js';
    import { meshToVoxel } from './utils/meshToVolume.js';
    import { voxelToNRRD } from './utils/nrrdEncoder.js';

    import {
      buildVolumeTable,
      createLeftLabelSection
    } from './volumeInfoTable.js';

    import {
      adjustMeshCanvasSize,
      makeLabel,
      fitCameraToMeshes,
      animate
    } from './viewer/meshViewer.js'

    import {
      MeshController
    } from './meshControlTable.js';

    import {
      showMultiVolumeView,
      createTopLeftFromAnotherView,
      showTopVolumeOnly
    } from './viewer/niiViewer.js'

    const originalWarn = console.warn;

    console.warn = (...args) => {
      if (args[0] && args[0].includes("niivue-warn")) {
        return; // Niivue ê´€ë ¨ ê²½ê³ ëŠ” ë¬´ì‹œ
      }
      originalWarn(...args); // ë‹¤ë¥¸ ê²½ê³ ëŠ” ê·¸ëŒ€ë¡œ ì¶œë ¥
    };

    let threeMeshes = [];
    let meshMap = {};
    let hiddenFaces = new Map();
    let selectedMesh = null;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredMesh = null;
    let meshController = null;

    const canvas = document.getElementById('threeCanvas');
    let scene, camera, renderer;

    let controls = null;
    let nvMulti = null;     // ë©€í‹°í”Œë ˆì¸ ë·°ì–´
    let nvRender = null;    // ë Œë” ë·°ì–´
    let niiUrl = null;

    const labelColorMap1 = {
      1: [238, 112, 70, 255],   // Liver - ë¶‰ì€ ì£¼í™©
      2: [238, 112, 70, 255],   // Rt.lobe
      3: [218, 108, 110, 255],  // RAS - ì—°ë¶‰ì€ìƒ‰
      4: [138, 117, 231, 255],  // RPS - ë³´ë¼
      5: [211, 255, 51, 255],   // Lt.lobe - ë…¸ë‘
      6: [255, 50, 50, 255],   // âœ… LLS - ê°•í•œ ì£¼í™© (ê¸°ì¡´ë³´ë‹¤ ë¶‰ì€ í†¤)
      7: [40, 255, 120, 255],    // âœ… LMS - ì§„í•œ ì—°ë‘ â†’ ì±„ë„ ê°•í™”
      8: [50, 230, 120, 255],   // âœ… Spigelian - ë¯¼íŠ¸ë³´ë‹¤ ì§„í•œ ì´ˆë¡
      9: [193, 157, 255, 255],  // PV - ì—°ë³´ë¼
      10: [139, 186, 255, 255], // HV - í•˜ëŠ˜ìƒ‰
      11: [234, 36, 36, 255],   // Cancer - ê°•ë ¬í•œ ë¹¨ê°•
      12: [50, 230, 120, 255],    // âœ… BD - ê°•í•œ ë…¹ìƒ‰ (ê°ˆìƒ‰ ëŠë‚Œ ì œê±°)
      // 255: [255, 255, 255, 255]  // í¸ì§‘ëœ ë¶€ë¶„ - í•˜ì–€ìƒ‰
      255: [1.0, 1.0, 1.0, 0.0]   // í¸ì§‘ëœ ë¶€ë¶„ - íˆ¬ëª…
    };

    initThreeJS()
    loadTestVolumes();

    export async function renderVolumeMeshAndSlices(niiUrl, nrrdUrl, scene, camera, renderer, controls) {
      // âœ… ë©”ì‹œ ìƒì„± ë° threeMeshes ì „ì—­ ì„¤ì •
      const meshes = await renderNrrdMesh(scene, camera, renderer, nrrdUrl);

      initMeshMap(meshes);
      addMeshsToScene(meshes);

      // ì¹´ë©”ë¼ ë§ì¶¤
      if (meshes.length > 0) {
        fitCameraToMeshes(meshes, camera, controls, renderer, scene);
      }

      animate(controls, renderer, scene, camera);

      const bottomView = await showMultiVolumeView(niiUrl, nrrdUrl, labelColorMap1);
      nvMulti = bottomView;
      const topLeftView = await createTopLeftFromAnotherView(bottomView);

      topLeftView.onLocationChange = (location) => {
        console.log("Current pointer location:", location)
      }

      const nvRender = await showTopVolumeOnly(bottomView);

      buildVolumeTable(meshes, bottomView.volumes[1], scene);

      topLeftView.setRadiologicalConvention(true);
      bottomView.setRadiologicalConvention(true);

      bottomView.broadcastTo([topLeftView], { "2d": true, "3d": true });
      topLeftView.broadcastTo([bottomView], { "2d": true, "3d": true });

      lassoEditor.setRenderInstance(nvRender);
      lassoEditor.setMultiInstance(bottomView);
      lassoEditor.setTopLeftView(topLeftView);

      if (!bottomView || bottomView.volumes.length < 2) {
        console.warn("âš ï¸ Niivueì— ë³¼ë¥¨ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
      } else {
        console.log("âœ… ë³¼ë¥¨ ë¡œë“œ ì™„ë£Œ:", bottomView.volumes.map(v => v.name));
      }

      // ë³¼ë¥¨ì˜ ê³µê°„ìƒì˜ ìœ„ì¹˜ê°€ ì˜ ë˜ì–´ìˆëŠ”ì§€ í™•ì¸ì„ ìœ„í•œ ë°”ìš´ë”© ë°•ìŠ¤
      // showVolumeBoundingBox(nvRender.volumes[0])

      // logVolumeAndMeshStats(nvRender, camera, controls);

      return meshes;
    }

    function initThreeJS() {
      renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
      const ro = new ResizeObserver(() => adjustMeshCanvasSize(canvas, renderer, camera));
      ro.observe(canvas);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 5000);
      camera.position.set(500, 500, 500);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      adjustMeshCanvasSize(canvas, renderer, camera);

      // âœ… AmbientLight: ì „ì²´ì ì¸ ê¸°ë³¸ ë°ê¸°
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      // âœ… HemisphereLight: ìì—°ìŠ¤ëŸ¬ìš´ ìƒ/í•˜ ë°©í–¥ ì¡°ëª…
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
      hemiLight.position.set(0, 200, 0);
      scene.add(hemiLight);

      // âœ… DirectionalLight: ì¹´ë©”ë¼ ê¸°ì¤€ ë™ê¸°í™” (ë©”ì¸ ë¼ì´íŠ¸)
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
      mainLight.position.set(0, 200, 200);
      scene.add(mainLight);

      // âœ… ë¼ì´íŠ¸ í—¬í¼ (ê°œë°œìš©)
      const light = new THREE.DirectionalLight(0xffffff, 1.0);
      light.position.set(50, 100, 50);
      scene.add(light);

      // âœ… í—¬í¼ ì¶”ê°€ (í¬ê¸° 5)
      const helper = new THREE.DirectionalLightHelper(light, 5);
      scene.add(helper);

      // âœ… TrackballControls ì„¤ì •
      controls = new TrackballControls(camera, canvas);
      controls.rotateSpeed = 4.0;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 0.8;
      controls.staticMoving = true;
      controls.dynamicDampingFactor = 0.3;

      // âœ… ì¹´ë©”ë¼ ì›€ì§ì„ â†’ ë¼ì´íŠ¸ ìœ„ì¹˜ ë™ê¸°í™”
      controls.addEventListener('change', () => {
        mainLight.position.copy(camera.position.clone().add(new THREE.Vector3(0, 100, 100)));
        mainLight.lookAt(scene.position);
      });

      // âœ… ì¶• í‘œì‹œ + ë¼ë²¨
      const axisGroup = new THREE.Group();
      const axesHelper = new THREE.AxesHelper(500);
      axisGroup.add(axesHelper);

      scene.add(makeLabel('X', 'red', new THREE.Vector3(500, 0, 0)));   // +X (Right)
      scene.add(makeLabel('Y', 'blue', new THREE.Vector3(0, 500, 0))); // +y (Anterior)
      scene.add(makeLabel('Z', 'green', new THREE.Vector3(0, 0, 500))); // +Z (Superior)

      scene.add(makeLabel('L', 'red', new THREE.Vector3(250, 0, 0)));   // +X (Right)
      scene.add(makeLabel('P', 'blue', new THREE.Vector3(0, 250, 0))); // +y (Anterior)
      scene.add(makeLabel('S', 'green', new THREE.Vector3(0, 0, 250))); // +Z (Superior)

      scene.add(axisGroup);
    }

    const input = document.getElementById('dicomInput');
    const status = document.getElementById('status');

    let meshes = [];

    input.addEventListener('change', async (e) => {
      try {
        const { niiUrl, nrrdUrl } = await uploadAndInferDicomBundle(
          e.target.files,
          'http://127.0.0.1:5051/infer-dicom-bundle',
          (msg) => status.textContent = msg
        );
        meshes = await renderVolumeMeshAndSlices(niiUrl, nrrdUrl, scene, camera, renderer, controls, lassoEditor);

        meshController = new MeshController(meshes, scene, lassoEditor, camera);
        buildMeshControllers(meshes, scene);
      } catch (err) {
        console.error(err);
        status.textContent = `âŒ ì˜¤ë¥˜: ${err.message}`;
      }
    });

    async function loadTestVolumes() {
      const [niiBlob, nrrdBlob] = await Promise.all([
        fetch('./data/converted.nii.gz').then(res => res.blob()),
        fetch('./data/inferred.nrrd').then(res => res.blob())
      ]);

      const nrrdUrl = URL.createObjectURL(nrrdBlob);
      niiUrl = URL.createObjectURL(niiBlob);

      meshes = await renderVolumeMeshAndSlices(niiUrl, nrrdUrl, scene, camera, renderer, controls);
      meshController = new MeshController(meshes, scene, lassoEditor);
      meshController.buildMeshControllers();
    }

    function initMeshMap(meshes) {
      meshMap = {};
      meshes.forEach(m => {
        meshMap[m.userData.label] = m;
      });
    }

    window.initMeshMap = initMeshMap;

    function showVolumeBoundingBox(volume) {
      const origin = lassoEditor.voxelToWorldCoordinates(0, 0, 0, volume);
      const maxDims = volume.hdr.dims.slice(1);
      const boundingMax = lassoEditor.voxelToWorldCoordinates(
        maxDims[0], maxDims[1], maxDims[2],
        volume);

      console.log("ğŸ“ Origin in world coordinates:", origin, boundingMax);

      const box = new THREE.Box3(
        origin,
        boundingMax
      );
      const helper = new THREE.Box3Helper(box, 0x00ffcc);
      scene.add(helper);
    }

    let cameraAlreadySynced = false; // ìµœì´ˆ ë™ê¸°í™” ì—¬ë¶€ ì „ì—­ ìƒíƒœ

    function computeLabelVolumesDict(vol) {
      const data = vol.img;
      const pd = vol.hdr.pixDims;                    // [0, sx, sy, sz, ...]
      const voxelMM3 = Math.abs(pd[1] * pd[2] * pd[3]); // mmÂ³/voxel

      const counts = new Map();
      for (let i = 0; i < data.length; i++) {
        const v = data[i];
        if (v === 0) continue;                       // 0(ë°°ê²½) ì œì™¸
        counts.set(v, (counts.get(v) || 0) + 1);
      }

      const out = {};
      for (const [label, vox] of counts) {
        const mm = vox * voxelMM3;
        out[label] = { mm, mL: mm / 1000, numberOfVoxel: vox };
      }
      return out;
    }

    window.computeLabelVolumesDict = computeLabelVolumesDict;
    window.buildVolumeTable = buildVolumeTable;

    function addMeshsToScene(meshes) {
      meshes.forEach(mesh => {
        if (!mesh.material) return;

        scene.add(mesh);
      });
    }

    window.addMeshsToScene = addMeshsToScene;
    window.bindMeshControllers = () => meshController.bindMeshControllers;

    function getMeshByLabel(label) {
      return meshMap[label];
    }
    window.getMeshByLabel = getMeshByLabel;

    const lassoEditor = new LassoEditor(canvas, camera, renderer, scene, controls);
    window.lassoEditor = lassoEditor;

    document.getElementById('undoBtn').addEventListener('click', () => {
      if (lassoEditor.selectedMesh) {
        lassoEditor.undoManager.undo(lassoEditor.selectedMesh);
      }
    });

    const editorBtn = document.getElementById('editorBtn');
    const drawBtn = document.getElementById('drawBtn');
    const editModeBtn = document.getElementById('editModeBtn');
    const scissorIcon = document.getElementById('scissorIcon');

    // âœ… í¸ì§‘ ëª¨ë“œ ì „í™˜ ë²„íŠ¼
    editModeBtn.addEventListener('click', () => {
      lassoEditor.volumeEditFullMode = !lassoEditor.volumeEditFullMode;

      if (!lassoEditor.volumeEditFullMode) {
        editModeBtn.textContent = 'ğŸ¯ ë¶€ë¶„';
        editModeBtn.style.background = '#0066cc';
      } else {
        editModeBtn.textContent = 'ğŸŒ ì „ì²´';
        editModeBtn.style.background = '#222';
      }
    });

    editorBtn.addEventListener('click', () => {
      const isActive = !lassoEditor.editMode;
      lassoEditor.toggleEditMode(isActive);

      if (isActive) {
        editorBtn.textContent = 'âœ… í¸ì§‘ ì¤‘ (í´ë¦­í•´ì„œ ì¢…ë£Œ)';
        editorBtn.classList.add('edit-active');
        scissorIcon.style.display = 'block';

        // âœ… selectedMeshê°€ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ë©”ì‰¬ ìë™ ì„ íƒ
        if (!selectedMesh && threeMeshes.length > 0) {
          selectMesh(threeMeshes[0]); // ë‚´ë¶€ì ìœ¼ë¡œ highlight ì²˜ë¦¬
        } else if (selectedMesh) {
          highlightSelectedMesh(selectedMesh);
        }
      } else {
        editorBtn.textContent = 'âœ‚ï¸ í¸ì§‘ ëª¨ë“œ';
        editorBtn.classList.remove('edit-active');
        scissorIcon.style.display = 'none';
        meshController.clearAllHighlights();
      }
    });

    let drawMode = false;
    let isDrawing = false;

    drawBtn.addEventListener('click', () => {
      drawMode = !drawMode;
      console.log(drawMode);

      const segmentEditController = document.getElementById('segmentEditControllers');

      if (drawMode === true) {
        console.log(nvMulti.volumes);
        segmentEditController.style.display = 'flex';

        drawBtn.classList.add('edit-active');

        // ë™ì ìœ¼ë¡œ ë³€ê²½
        nvMulti.opts.penSize = 10;
        // nvMulti.drawScene();
        // nvMulti.setPenValue(0, false);
        nvMulti.drawRimOpacity = 0.6;
        // nvMulti.setDrawingEnabled(true);

        const nv = nvMulti;

        nv.setDrawingEnabled(true);
        nv.setDrawOpacity(0.6); // ë³´ì´ë„ë¡
        // í•µì‹¬: ê¸°ë³¸ ë“œë˜ê·¸ í–‰ë™ì„ "ì½œë°±ë§Œ"ìœ¼ë¡œ ì „í™˜
        if (typeof nv.setDragMode === 'function') {
          nv.setDragMode(nv.dragModes.callbackOnly);
        } else {
          // êµ¬ë²„ì „ ëŒ€ë¹„ ì•ˆì „ë§
          nv.opts.dragMode = nv.dragModes.callbackOnly;
          nv.drawScene();
        }

        // 2) ì´ˆê¸°í™”(ì„ íƒ)
        const mask = nv.drawBitmap;
        mask.fill(0);
        nv.refreshDrawing(); // ë“œë¡œì‰ í…ìŠ¤ì²˜ ê°±ì‹  (updateGLVolume ì•„ë‹˜)

        const canvas = nv.gl?.canvas || nv.canvas;

        canvas.addEventListener('pointerdown', () => { isDrawing = true; });
        canvas.addEventListener('pointerup', () => { isDrawing = false; });
        canvas.addEventListener('pointerleave', () => { isDrawing = false; });

        // ë“œë˜ê·¸ ì¤‘ ìœ„ì¹˜ê°€ ë°”ë€” ë•Œë§ˆë‹¤ í˜¸ì¶œë¨
        nv.onLocationChange = (loc) => {
          if (!isDrawing) return;

          // voxel ì¢Œí‘œ
          const x = Math.floor(loc.vox[0]);
          const y = Math.floor(loc.vox[1]);
          const z = Math.floor(loc.vox[2]);

          // ë°°ê²½ ë³¼ë¥¨ í¬ê¸°
          const dims = nv.volumes[0].hdr.dims; // [_, nx, ny, nz, ...]
          const nx = dims[1], ny = dims[2], nz = dims[3];
          if (x < 0 || y < 0 || z < 0 || x >= nx || y >= ny || z >= nz) return;

          // ë¸ŒëŸ¬ì‹œ ë°˜ì§€ë¦„(ë³´xel ë‹¨ìœ„)
          const r = nv.opts.penSize | 0; // ì˜ˆ: 3
          for (let dz = -r; dz <= r; dz++) {
            const zz = z + dz; if (zz < 0 || zz >= nz) continue;
            for (let dy = -r; dy <= r; dy++) {
              const yy = y + dy; if (yy < 0 || yy >= ny) continue;
              for (let dx = -r; dx <= r; dx++) {
                const xx = x + dx; if (xx < 0 || xx >= nx) continue;
                if (dx * dx + dy * dy + dz * dz > r * r) continue; // êµ¬í˜• ë¸ŒëŸ¬ì‹œ ë‚´ë¶€ë§Œ

                const idx = xx + yy * nx + zz * nx * ny; // 1D ì¸ë±ì‹±
                mask[idx] = 4; // ì›í•˜ëŠ” ë¼ë²¨ ê°’
              }
            }
          }

          nv.refreshDrawing(); // í…ìŠ¤ì²˜ ê°±ì‹  (í•„ìˆ˜)
          // nv.drawScene();   // í•„ìš” ì‹œ
        };


      } else {
        segmentEditController.style.display = 'none';
        drawBtn.classList.remove('edit-active');
        nvMulti.setDrawingEnabled(false);

        const draw = nvMulti.drawBitmap;
        draw.fill(0);         // ëª¨ë“  voxel ê°’ 0ìœ¼ë¡œ
        nvMulti.refreshDrawing();
      }
    });

    const nv = new niivue.Niivue({
      sliceType: niivue.SLICE_TYPE.MULTIPLANE,
      backColor: [0, 0, 0, 1]
    });
    await nv.attachTo("canvasTop");

    // âœ… NRRD í—¤ë” íŒŒì‹± & ë¡œê·¸ ì¶œë ¥
    async function logNrrdHeader(blob) {
      const text = await blob.text();
      const header = text.split("\n\n")[0];
      console.log("===== [NRRD Header ë¡œê·¸] =====");
      console.log(header);
      console.log("â†’ sizes:", (header.match(/sizes:\s+([\d\s]+)/) || [])[1]);
      console.log("â†’ origin:", (header.match(/space origin:\s+\((.*?)\)/) || [])[1]);
    }

    // âœ… Niivue HDR ì •ë³´ ì¶œë ¥
  </script>


  <style>
    .d-none {
      display: none;
    }

    .selected-row {
      border: 2px solid #00aaff;
      background-color: rgba(0, 123, 255, 0.15);
      border-radius: 8px;
      box-shadow: 0 0 6px rgba(0, 123, 255, 0.3);
    }

    #editorBtn.edit-active {
      background: #007bff !important;
      /* íŒŒë€ìƒ‰ ê°•ì¡° */
      border: 2px solid #00aaff !important;
      color: white;
      font-weight: bold;
    }

    #drawBtn.edit-active {
      background: #007bff !important;
      /* íŒŒë€ìƒ‰ ê°•ì¡° */
      border: 2px solid #00aaff !important;
      color: white;
      font-weight: bold;
    }

    html,
    body {
      height: 100vh;
      margin: 0;
      padding: 0;
      background: black;
    }

    header {
      width: 100vw;
      height: 56px;
      /* í•„ìš”ì— ë”°ë¼ 40~80px */
      min-height: 40px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #ddd;
      box-sizing: border-box;
      padding-left: 10px;
    }

    #meshSidebar {
      pointer-events: auto;
      z-index: 10;
      flex: 0 1 270px;
      min-width: 150px;
      border-right: 1px solid #ddd;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      height: 100%;
      min-width: 270px;
    }

    #topHalf {
      display: flex;
      flex-direction: column;

      border-color: red;
      border-style: solid;
    }

    #bottomHalf {
      flex: 1;
      display: flex;
      flex-direction: column;

      border-color: red;
      border-style: solid;
    }

    #threeCanvas {
      pointer-events: auto;
      /* ë˜ëŠ” all */
      z-index: 1;

      width: 100%;
      height: 100%;
      display: flex;
    }

    #threeCanvas.crosshair {
      cursor: crosshair !important;
    }

    .selected-row {
      border: 2px solid #00aaff;
      background-color: rgba(0, 123, 255, 0.15);
      border-radius: 10px;
      box-shadow: 0 0 4px rgba(0, 123, 255, 0.3);
    }

    #mainLayout {
      display: flex;
      flex-direction: row;
      /* ëª…ì‹œì ìœ¼ë¡œ ì¢Œ-ì¤‘-ìš° ë°°ì¹˜ */
      width: 100vw;
      height: calc(100vh - 56px);
      /* overflow: hidden; */
    }

    #viewerArea {
      flex: 1 1 auto;
      /* ë‚¨ëŠ” ê³µê°„ ë‹¤ ì‚¬ìš© */
      min-width: 0;
      /* overflow ë°©ì§€ */
      display: flex;
      flex-direction: column;
      height: 100%;

    }

    #volumeTableArea {
      width: 500px;
      background: #000000;
      padding: 16px;
      border-left: 1px solid #ccc;
      overflow-y: auto;
      height: 100%;
      box-sizing: border-box;
      z-index: 1;
    }

    header button,
    header input[type="file"] {
      font-size: 14px;
      background-color: #000000;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      margin-right: 8px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    header button:hover,
    header input[type="file"]:hover {
      background-color: #0056b3;
    }

    header button:active,
    header input[type="file"]:active {
      background-color: #004999;
    }

    header #status {
      font-size: 14px;
      color: white;
      margin-left: 12px;
    }

    #volumeTableContent table {
      width: 100%;
      border-collapse: collapse;
      font-size: 15px;
      border: 1px solid #ccc;
    }

    #volumeTableContent thead {
      background-color: #004c7f;
      /* ì¢€ ë” ê¹Šì€ ë¸”ë£¨ */
      color: white;
    }

    #volumeTableContent thead th {
      padding: 10px;
      border-bottom: 1px solid #ccc;
      text-align: left;
    }

    #volumeTableContent tbody tr:nth-child(even) {
      background-color: #f2f6f9;
    }

    #volumeTableContent tbody tr:nth-child(odd) {
      background-color: #e8eff5;
    }

    #volumeTableContent tbody td {
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }

    #volumeTableContent tbody tr:last-child {
      background-color: #e0f0ff;
      /* Total í–‰ ë°°ê²½ */
      font-weight: bold;
    }

    #volumeTableContent tbody tr:last-child td {
      color: #003366;
    }
  </style>
</body>

</html>